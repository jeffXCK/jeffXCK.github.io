---
title: Redis持久化——RDB（Redis DataBase）
comments: false
date: 2019-08-22 07:44:34
categories: Redis
tags: Redis
---

### 一、是什么？
> - 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的快照(Snapshot)，它恢复时是将快照文件直接读到内存里。
> - Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
> - 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。
#### 优势
> - 适合进行大规模数据的恢复，且对数据恢复的完整性和一致性要求不高，那么RDB方式要比AOF方式更加的高效。
#### 劣势
> - 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。
> - fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑
### 二、Fork定义
> - fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（*变量、环境变量、程序计数器等*）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。
### 三、RDB触发配置
#### 自动触发（配置文件中的默认配置）：
> - RDB持久化是以dump.rdb文件的形式保存在磁盘中的。这是整个内存经过压缩的快照（Snapshot）文件。可以配置复合的快照触发条件：
```
save 900 1  # 或15分钟内改了1次。
save 300 10  # 或5分钟内改了10次，
save 60 10000  # 是1分钟内改了1万次，
```
#### 手动触发（执行命令：save或者bgsave）：
> - save：save时只管保存，其它不管，全部阻塞。
> - bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。
> - 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。
> - 如果当前set的数据非常重要，等不及Redis默认配置自动触发，必须立即备份，则可以手动执行save或者bgsave命令立即备份：
```
127.0.0.1:6379> set k1 "非常重要的数据"
OK
127.0.0.1:6379> save
```
#### 禁用RDB持久化的策略
> - 不设置任何save指令：
```
# save  ""
# 默认
# save 900 1
# save 300 10
# save 60 10000
```
> - 或者给save传入一个空字符串参数也可以：
```
save  ""
# 默认
# save 900 1
# save 300 10
# save 60 10000
```
> - 动态停止所以RDB保存规则的方法：
```
127.0.0.1:6379> redis-cli config set save ""
```
### 四、RDB其他配置：
```
# 设置后台save出错以后禁止前台写入操作，一般采用默认配置yes即可
# 如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制
stop-writes-on-bgsave-error yes

# 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，也采用默认配置yes即可
rdbcompression yes

# 在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能
rdbchecksum yes

# 数据库转储的文件名
dbfilename dump.rdb

# 工作目录。
# RDB将在这个目录中编写，并指定文件名，上面使用'dbfilename'配置指令。
# AOF（ Append Only File）也将在这个目录中创建。
# 注意：这里必须指定一个目录，而不是文件名。
dir ./
```
### 五、总结
![RDB.png](https://upload-images.jianshu.io/upload_images/18660770-9f7dbe146c3a5fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


> - RDB是一个非常紧凑的文件
> - RDB在保存rdb文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他的IO操作，所以RDB持久化方式可以最大化Redis的性能。
> - 与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些。
> - 数据丢失的风险大。
> - RDB 需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致Redis在一些毫秒级不能响应客户端请求。